import jsPDF from 'jspdf'
import html2canvas from 'html2canvas'
import type { RuleResult } from '../types'

/**
 * Generates a PDF from the DecisionCard component
 */
export async function generateDecisionCardPDF(
  element: HTMLElement,
  result: RuleResult,
  filename?: string
): Promise<void> {
  try {
    // Create canvas from the element
    const canvas = await html2canvas(element, {
      scale: 2, // Higher quality
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff',
      logging: false,
    })

    // Calculate dimensions
    const imgWidth = 210 // A4 width in mm
    const pageHeight = 295 // A4 height in mm
    const imgHeight = (canvas.height * imgWidth) / canvas.width
    let heightLeft = imgHeight

    // Create PDF
    const pdf = new jsPDF('p', 'mm', 'a4')
    const imgData = canvas.toDataURL('image/png')

    // Add image to PDF
    pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight)
    heightLeft -= pageHeight

    // Add additional pages if content is longer than one page
    while (heightLeft >= 0) {
      pdf.addPage()
      pdf.addImage(imgData, 'PNG', 0, -(pageHeight - heightLeft), imgWidth, imgHeight)
      heightLeft -= pageHeight
    }

    // Generate filename if not provided
    const defaultFilename = `planright-assessment-${result.decision.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.pdf`
    const finalFilename = filename || defaultFilename

    // Download the PDF
    pdf.save(finalFilename)
  } catch {
    throw new Error('Failed to generate PDF. Please try again.')
  }
}

/**
 * Generates a text-based PDF report with structured data
 */
export function generateTextPDF(
  result: RuleResult,
  filename?: string
): void {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4')
    
    // Set up fonts and colors
    pdf.setFont('helvetica', 'bold')
    pdf.setFontSize(20)
    pdf.setTextColor(0, 0, 0)
    
    // Title
    pdf.text('PlanRight Assessment Report', 20, 30)
    
    // Decision
    pdf.setFontSize(16)
    pdf.setTextColor(0, 100, 0) // Green for exempt, will be overridden
    if (result.decision === 'Likely Not Exempt') {
      pdf.setTextColor(200, 0, 0) // Red
    } else if (result.decision === 'Cannot assess') {
      pdf.setTextColor(200, 150, 0) // Amber
    }
    pdf.text(`Decision: ${result.decision}`, 20, 50)
    
    // Summary
    pdf.setFont('helvetica', 'normal')
    pdf.setFontSize(12)
    pdf.setTextColor(0, 0, 0)
    pdf.text(`Total Checks: ${result.checks.length}`, 20, 70)
    
    const failCount = result.checks.filter(c => !c.pass).length
    const passCount = result.checks.filter(c => c.pass).length
    
    pdf.text(`Failed: ${failCount}`, 20, 80)
    pdf.text(`Passed: ${passCount}`, 20, 90)
    
    if (result.errors.length > 0) {
      pdf.text(`Validation Errors: ${result.errors.length}`, 20, 100)
    }
    
    // Key findings
    pdf.setFont('helvetica', 'bold')
    pdf.setFontSize(14)
    pdf.text('Key Findings', 20, 120)
    
    pdf.setFont('helvetica', 'normal')
    pdf.setFontSize(10)
    
    let yPosition = 135
    const topChecks = result.checks
      .sort((a, b) => {
        // Critical fails first, then other fails, then passes
        if (a.killer && !a.pass) return -1
        if (b.killer && !b.pass) return 1
        if (!a.pass && b.pass) return -1
        if (a.pass && !b.pass) return 1
        return 0
      })
      .slice(0, 10) // Top 10 most important checks
    
         topChecks.forEach((check, _index) => {
      if (yPosition > 280) {
        pdf.addPage()
        yPosition = 20
      }
      
      const status = check.pass ? '✓' : '✗'
      const severity = check.killer ? 'CRITICAL' : check.pass ? 'PASS' : 'FAIL'
      
      pdf.setFont('helvetica', 'bold')
      pdf.text(`${status} ${severity}:`, 20, yPosition)
      
      pdf.setFont('helvetica', 'normal')
      const label = normalizeCheckLabel(check)
      const lines = pdf.splitTextToSize(label, 160)
      pdf.text(lines, 30, yPosition)
      
      yPosition += lines.length * 5 + 5
    })
    
    // Footer
    const pageCount = pdf.getNumberOfPages()
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i)
      pdf.setFont('helvetica', 'normal')
      pdf.setFontSize(8)
      pdf.setTextColor(128, 128, 128)
      pdf.text(`Generated by PlanRight on ${new Date().toLocaleDateString()}`, 20, 285)
      pdf.text(`Page ${i} of ${pageCount}`, 180, 285)
    }
    
    // Generate filename if not provided
    const defaultFilename = `planright-assessment-${result.decision.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.pdf`
    const finalFilename = filename || defaultFilename
    
    // Download the PDF
    pdf.save(finalFilename)
  } catch {
    throw new Error('Failed to generate PDF. Please try again.')
  }
}

/**
 * Normalize check labels for PDF display
 */
function normalizeCheckLabel(check: any): string {
  const { rule_id, note } = check
  
  // Map known patterns to user-friendly labels with clear explanations
  const labelMappings: Record<string, string> = {
    'on_easement': 'Cannot build on easement',
    'over_sewer': 'Cannot build over sewer lines',
    'behind_building_line': 'Must be behind building line',
    'setback_front': 'Front setback distance required',
    'setback_side': 'Side setback distance required', 
    'setback_rear': 'Rear setback distance required',
    'height_max': 'Maximum height limit',
    'area_max': 'Maximum floor area limit',
    'heritage_item': 'Heritage item protection zone',
    'conservation_area': 'Conservation area restrictions',
    'flood_prone': 'Flood prone area limitations',
    'bushfire_prone': 'Bushfire prone area requirements',
    'attached_to_dwelling': 'Must attach to main dwelling',
    'shipping_container': 'Shipping containers not allowed',
    'non_combustible': 'Non-combustible materials required',
    'roof_clearance': 'Roof boundary clearance needed',
    'class_7a': 'Class 7a buildings prohibited',
  }

  // Try to match rule_id patterns
  for (const [pattern, label] of Object.entries(labelMappings)) {
    if (rule_id.toLowerCase().includes(pattern)) {
      return label
    }
  }

  // Fallback to note if no pattern matches
  return note || rule_id
}
